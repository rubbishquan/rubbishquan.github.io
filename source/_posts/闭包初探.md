---
title: 闭包初探
date: 2016-12-30 12:22:05
tags: 
- javascript
---
  作用域的好处是内部函数可以访问到定义他们的外部函数的参数和变量(除了this和argument)。
  
  简单来说，闭包就是在另一个作用域中保存了一份它从上一级函数或作用域取得的变量（键值对），而这些键值对是不会随上一级函数的执行完成而销毁。
  
  变量的作用域有两种，一种是全局作用域，另一种是局部作用域。
    <!--more-->
  函数内部可以访问自己的变量和全局作用域中的变量，但是函数外部不能访问函数内定义的变量。
  
  如果我们想要访问到函数内局部定义的变量，就需要在函数的内部再定义一个函数。  
```
  function f1() {
     var i = 1
     function f2() {
       console.log(i) //1
     }
     return f2
}
var result = f1()
result()  //1
```
闭包最大的特点就是能记住’它的诞生环境‘，f2记住了f1的’诞生环境‘所以从f2可以得到f1的变量。

闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。
```
function Increment(start) {
  return function () {
  return start++;
  };
}
var inc = Increment(5);
inc() // 5
inc() // 6
inc() // 7
```
上面代码中，start是函数Increment的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数Increment的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。

为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于Incrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。

闭包的另一个用处，是封装对象的私有属性和私有方法。
我们构造一个object对象， 它拥有一个value属性，它对于Increment和getValue方法总是可用的，但他的作用域对于其他函数却是不可见的。
```
 var object = (function() {
  var value = 0
  return {
    increment: function(inc) {
      value += typeof inc === 'number' ? inc : 1
    },
    getValue: function() {
      return value
    }
  }
}())
```
//注意最后一行的“()”，这种调用叫作"立即执行函数表达式（IIFE)"，以后解释。

这里并没有把一个函数赋值给myObject，是把函数调用后的返回值赋给它。